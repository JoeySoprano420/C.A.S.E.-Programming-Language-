Fn tokenize "string src" {
    Print "Lexing..." [end]
    let i = 0
    loop "i < src.length()" {
        if src[i] == ' ' {
            call skipSpace [end]
        } else if src[i] == '\n' {
            call nextLine [end]
        } else if isLetter src[i] {
            call readIdent [end]
        } else if src[i] == '"' {
            call readString [end]
        } else if isDigit src[i] {
            call readNumber [end]
        } else {
            call readSymbol [end]
        }
        i = i + 1
    } [end]
    ret tokens
} [end]

Fn readIdent "char c" {
    let buf = ""
    loop "isIdentChar(src[i])" {
        buf = buf + src[i]
        i = i + 1
    } [end]
    if isKeyword buf {
        call pushToken "KEYWORD", buf [end]
    } else {
        call pushToken "IDENT", buf [end]
    }
} [end]

Fn readString "none" {
    let val = ""
    i = i + 1
    loop "src[i] != '\"'" {
        val = val + src[i]
        i = i + 1
    } [end]
    call pushToken "STRING", val [end]
    i = i + 1
} [end]

Fn parseProgram "tokens t" {
    let pos = 0
    let root = Node "Program"
    loop "pos < t.size()" {
        call append root, parseStatement [end]
    } [end]
    ret root
} [end]

Fn parseStatement "none" {
    if peek().value == "Print" {
        ret parsePrint
    } else if peek().value == "loop" {
        ret parseLoop
    } else if peek().value == "if" {
        ret parseIf
    } else if peek().value == "Fn" {
        ret parseFn
    } else if peek().value == "call" {
        ret parseCall
    } else if peek().value == "let" {
        ret parseLet
    } else {
        call advance [end]
        ret Node "Unknown", peek().value
    }
} [end]

Fn parsePrint "none" {
    call advance [end]
    let n = Node "Print"
    if peek().type == "STRING" {
        n.value = peek().value
        call advance [end]
    }
    ret n
} [end]
 
Fn emitNode "Node n" {
    if n.type == "Program" {
        Print "#include <iostream>" [end]
        loop "child in n.children" {
            if child.type == "Fn" {
                call emitNode child [end]
            }
        } [end]
        Print "int main(){" [end]
        loop "child in n.children" {
            if child.type != "Fn" {
                call emitNode child [end]
            }
        } [end]
        Print "return 0;}" [end]
    } else if n.type == "Print" {
        Print "std::cout << \"" + n.value + "\" << std::endl;" [end]
    } else if n.type == "Loop" {
        Print "for(" + n.value + "){" [end]
        loop "c in n.children" { call emitNode c [end] } [end]
        Print "}" [end]
    } else if n.type == "If" {
        Print "if(" + n.value + "){" [end]
        loop "c in n.children" { call emitNode c [end] } [end]
        Print "}" [end]
    }
} [end]
 
Fn main () {
    Print "C.A.S.E. Compiler Bootstrap" [end]
    call loadSource "compiler.case" [end]
    let toks = call tokenize src
    let ast = call parseProgram toks
    call emitCPP ast [end]
} [end]
 

